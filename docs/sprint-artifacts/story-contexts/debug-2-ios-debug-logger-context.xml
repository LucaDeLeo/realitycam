<?xml version="1.0" encoding="UTF-8"?>
<story-context story-key="debug-2-ios-debug-logger">
  <metadata>
    <generated>2025-12-06</generated>
    <source-story>docs/sprint-artifacts/stories/debug-2-ios-debug-logger.md</source-story>
    <source-tech-spec>docs/tech-spec.md</source-tech-spec>
    <source-architecture>docs/architecture.md</source-architecture>
    <workflow-type>Quick-Flow</workflow-type>
    <epic-spec-note>This is a Quick-Flow feature. The tech-spec (docs/tech-spec.md) serves as the combined PRD and epic specification. No separate PRD or epic document exists.</epic-spec-note>
  </metadata>

  <story-summary>
    Implement iOS debug logging infrastructure for DEBUG builds only:
    - Core/Debug directory with three files: DebugLogEntry.swift, DebugLogger.swift, DebugLogShipper.swift
    - DebugLogEntry model with Codable conformance for JSON serialization (id, correlationId, timestamp, source, level, event, payload, deviceId, sessionId)
    - DebugLogger singleton using Actor-based concurrency (@MainActor) with buffering (50 entries or 30-second timeout)
    - DebugLogShipper for batch POST to /debug/logs endpoint
    - X-Correlation-ID header added to all APIClient requests
    - Background flush when app enters background (scenePhase observer in RialApp.swift)
    - All code wrapped in #if DEBUG preprocessor directives for zero production impact
  </story-summary>

  <acceptance-criteria>
    <ac id="AC1">Core/Debug directory created with three files: DebugLogger.swift, DebugLogEntry.swift, DebugLogShipper.swift</ac>
    <ac id="AC2">DebugLogEntry model with all required fields (id, correlationId, timestamp, source, level, event, payload, deviceId, sessionId) and Codable conformance for JSON serialization</ac>
    <ac id="AC3">DebugLogger singleton with log(event:level:payload:correlationId:) and flush() async methods, using Actor-based concurrency (@MainActor)</ac>
    <ac id="AC4">Buffer ships automatically when hitting 50 entries OR 30-second timeout (whichever comes first)</ac>
    <ac id="AC5">DebugLogShipper performs batch POST to /debug/logs endpoint with proper JSON encoding</ac>
    <ac id="AC6">X-Correlation-ID header (UUID) added to all APIClient requests (GET, POST, perform methods)</ac>
    <ac id="AC7">App flushes debug logs when entering background (scenePhase change in RialApp.swift or AppDelegate)</ac>
    <ac id="AC8">All debug logging code wrapped in #if DEBUG preprocessor directives - zero code in Release builds</ac>
    <ac id="AC9">Unit tests for DebugLogger buffering logic, DebugLogEntry serialization, and DebugLogShipper</ac>
  </acceptance-criteria>

  <existing-patterns>
    <pattern name="api-client">
      <description>APIClient uses URLSession with Logger for debug output, JSON encoder/decoder with snake_case conversion</description>
      <code-reference file="ios/Rial/Core/Networking/APIClient.swift" lines="35-62">
        <![CDATA[
final class APIClient {
    private static let logger = Logger(subsystem: "app.rial", category: "api-client")

    /// Base URL for API requests
    let baseURL: URL

    /// Device signature service (optional - some endpoints don't require auth)
    private let deviceSignature: DeviceSignature?

    /// URLSession for standard requests
    private let session: URLSession

    /// JSON encoder configured for API
    private let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.keyEncodingStrategy = .convertToSnakeCase
        return encoder
    }()

    /// JSON decoder configured for API
    private let decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return decoder
    }()
        ]]>
      </code-reference>
      <code-reference file="ios/Rial/Core/Networking/APIClient.swift" lines="155-174">
        <![CDATA[
/// Perform raw request (used for multipart uploads).
///
/// - Parameter request: Configured URLRequest
/// - Returns: Decoded response
func perform<T: Decodable>(_ request: URLRequest) async throws -> T {
    Self.logger.debug("Request: \(request.httpMethod ?? "?") \(request.url?.path ?? "?")")

    let (data, response) = try await session.data(for: request)

    guard let httpResponse = response as? HTTPURLResponse else {
        throw APIError.invalidResponse
    }

    Self.logger.debug("Response: \(httpResponse.statusCode) (\(data.count) bytes)")

    try validateResponse(httpResponse, data: data)

    do {
        return try decoder.decode(T.self, from: data)
    } catch {
        Self.logger.error("Decode error: \(error.localizedDescription)")
        throw APIError.decodeFailed(error)
    }
}
        ]]>
      </code-reference>
    </pattern>

    <pattern name="upload-service-singleton">
      <description>UploadService uses singleton pattern with NSObject inheritance for URLSession delegate, NSLock for thread safety</description>
      <code-reference file="ios/Rial/Core/Networking/UploadService.swift" lines="42-89">
        <![CDATA[
final class UploadService: NSObject {
    private static let logger = Logger(subsystem: "app.rial", category: "upload-service")

    /// ISO8601 formatter for metadata timestamps (reused across uploads)
    private static let iso8601Formatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        return formatter
    }()

    /// Background session identifier
    static let sessionIdentifier = "app.rial.upload"

    /// Shared singleton instance
    static let shared = UploadService()

    /// Base URL for API
    private var baseURL: URL?

    /// Capture store for status updates
    private var captureStore: CaptureStore?

    /// Keychain for device state
    private var keychain: KeychainService?

    /// Background URLSession (lazy initialized)
    private lazy var backgroundSession: URLSession = {
        let config = URLSessionConfiguration.background(withIdentifier: Self.sessionIdentifier)
        config.isDiscretionary = false
        config.sessionSendsLaunchEvents = true
        config.waitsForConnectivity = true
        config.timeoutIntervalForResource = 3600 // 1 hour max upload time
        config.httpAdditionalHeaders = [
            "Accept": "application/json",
            "User-Agent": "Rial-iOS/\(Self.appVersion)"
        ]

        return URLSession(configuration: config, delegate: self, delegateQueue: nil)
    }()

    /// Lock for thread-safe access to taskToCaptureMap
    private let lock = NSLock()

    // MARK: - Initialization

    /// Private initializer for singleton.
    private override init() {
        super.init()
    }
        ]]>
      </code-reference>
    </pattern>

    <pattern name="device-id-access">
      <description>Device ID accessed via KeychainService.loadDeviceState() which returns DeviceState with deviceId property</description>
      <code-reference file="ios/Rial/Core/Storage/KeychainService.swift" lines="624-636">
        <![CDATA[
/// Device state persisted in Keychain after registration
struct DeviceState: Codable {
    /// Unique device identifier (UUID string)
    let deviceId: String

    /// DCAppAttest key identifier (optional until registration completes)
    let attestationKeyId: String?

    /// Whether device has completed registration with backend
    let isRegistered: Bool

    /// Timestamp of successful registration (optional until registered)
    let registeredAt: Date?
}
        ]]>
      </code-reference>
      <code-reference file="ios/Rial/Core/Storage/KeychainService.swift" lines="319-336">
        <![CDATA[
/// Load device state from Keychain for a specific API environment.
func loadDeviceState(for apiBaseURL: URL) throws -> DeviceState? {
    let key = deviceStateKey(for: apiBaseURL)
    guard let data = try load(forKey: key) else {
        return nil
    }

    let decoder = JSONDecoder()
    decoder.dateDecodingStrategy = .iso8601

    do {
        let state = try decoder.decode(DeviceState.self, from: data)
        Self.logger.info("Loaded DeviceState from Keychain for \(apiBaseURL.host ?? "unknown")")
        return state
    } catch {
        Self.logger.error("Failed to decode DeviceState: \(error.localizedDescription)")
        throw KeychainError.decodingFailed
    }
}
        ]]>
      </code-reference>
    </pattern>

    <pattern name="codable-model">
      <description>Codable structs for JSON serialization with explicit CodingKeys for snake_case mapping where needed</description>
      <code-reference file="ios/Rial/Models/CaptureData.swift" lines="19-26">
        <![CDATA[
/// Mode of upload determining what data is sent to server.
public enum UploadMode: String, Codable, Sendable {
    /// Full upload mode - raw photo/video bytes uploaded
    case full = "full"

    /// Hash-only mode - only hash and metadata uploaded (privacy mode)
    case hashOnly = "hash_only"
}
        ]]>
      </code-reference>
      <code-reference file="ios/Rial/Models/CaptureData.swift" lines="171-220">
        <![CDATA[
/// Metadata associated with a capture.
public struct CaptureMetadata: Codable, Sendable, Equatable {
    /// Timestamp when the frame was captured
    public let capturedAt: Date

    /// Device model string (e.g., "iPhone 15 Pro")
    public let deviceModel: String

    /// SHA-256 hash of JPEG data (64-character hex string)
    public let photoHash: String

    /// GPS location data (optional - nil if denied or unavailable)
    public let location: LocationData?

    /// Depth map dimensions for reconstruction
    public let depthMapDimensions: DepthDimensions

    /// iOS version at capture time
    public let iosVersion: String

    /// App version at capture time
    public let appVersion: String
    // ...
}
        ]]>
      </code-reference>
    </pattern>

    <pattern name="app-lifecycle">
      <description>RialApp uses SwiftUI App protocol with @UIApplicationDelegateAdaptor for lifecycle events</description>
      <code-reference file="ios/Rial/App/RialApp.swift" lines="1-20">
        <![CDATA[
import SwiftUI

@main
struct RialApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    /// Privacy settings manager injected as environment object (Story 8-2)
    @StateObject private var privacySettings = PrivacySettingsManager()

    /// Navigation state for coordinating tab navigation after capture
    @StateObject private var navigationState = AppNavigationState()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(privacySettings)
                .environmentObject(navigationState)
        }
    }
}
        ]]>
      </code-reference>
    </pattern>

    <pattern name="os-log">
      <description>os.log Logger usage for structured logging with subsystem and category</description>
      <code-reference file="ios/Rial/Core/Networking/APIClient.swift" lines="36">
        <![CDATA[
private static let logger = Logger(subsystem: "app.rial", category: "api-client")
        ]]>
      </code-reference>
      <code-reference file="ios/Rial/Core/Networking/UploadService.swift" lines="43">
        <![CDATA[
private static let logger = Logger(subsystem: "app.rial", category: "upload-service")
        ]]>
      </code-reference>
      <code-reference file="ios/Rial/Core/Networking/DeviceRegistrationService.swift" lines="28">
        <![CDATA[
private static let logger = Logger(subsystem: "app.rial", category: "device-registration")
        ]]>
      </code-reference>
    </pattern>

    <pattern name="app-environment">
      <description>AppEnvironment provides API base URL with DEBUG conditional logic</description>
      <code-reference file="ios/Rial/Core/Configuration/AppEnvironment.swift" lines="15-50">
        <![CDATA[
enum AppEnvironment {
    // MARK: - API Configuration

    /// Base URL for the RealityCam API.
    ///
    /// Priority:
    /// 1. EnvironmentStore override (runtime debug settings, DEBUG only)
    /// 2. Info.plist `API_BASE_URL` key
    /// 3. Default production URL (https://rial-api.fly.dev)
    static var apiBaseURL: URL {
        #if DEBUG
        // Check for runtime debug override first
        if EnvironmentStore.shared.isOverrideActive {
            return EnvironmentStore.shared.apiBaseURL
        }
        #endif

        // Check Info.plist override
        if let urlString = Bundle.main.object(forInfoDictionaryKey: "API_BASE_URL") as? String,
           let url = URL(string: urlString) {
            return url
        }

        // Production URL (default for both DEBUG and RELEASE)
        return URL(string: "https://rial-api.fly.dev")!
    }

    /// Whether the app is running in debug mode
    static var isDebug: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
}
        ]]>
      </code-reference>
    </pattern>
  </existing-patterns>

  <implementation-guidance>
    <debug-log-entry-schema>
      <![CDATA[
#if DEBUG
/// Log entry for debug observability system.
/// Matches backend DebugLog schema for cross-stack correlation.
public struct DebugLogEntry: Codable, Sendable {
    let id: UUID
    let correlationId: UUID
    let timestamp: Date
    let source: LogSource      // Always .ios for this client
    let level: LogLevel        // .debug, .info, .warn, .error
    let event: String          // e.g., "API_REQUEST", "UPLOAD_START"
    let payload: [String: AnyCodable]  // Flexible JSON payload
    let deviceId: UUID?        // From KeychainService.loadDeviceState()
    let sessionId: UUID        // Generated per app session

    // CodingKeys for snake_case JSON encoding
    enum CodingKeys: String, CodingKey {
        case id
        case correlationId = "correlation_id"
        case timestamp
        case source
        case level
        case event
        case payload
        case deviceId = "device_id"
        case sessionId = "session_id"
    }
}

public enum LogLevel: String, Codable, Sendable {
    case debug, info, warn, error
}

public enum LogSource: String, Codable, Sendable {
    case ios, backend, web
}
#endif
      ]]>
    </debug-log-entry-schema>

    <any-codable-wrapper>
      <![CDATA[
#if DEBUG
/// Type-erased Codable wrapper for heterogeneous dictionary values.
/// Allows encoding [String: Any] payloads to JSON.
public struct AnyCodable: Codable, Sendable {
    public let value: Any

    public init(_ value: Any) {
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        if container.decodeNil() {
            self.value = NSNull()
        } else if let bool = try? container.decode(Bool.self) {
            self.value = bool
        } else if let int = try? container.decode(Int.self) {
            self.value = int
        } else if let double = try? container.decode(Double.self) {
            self.value = double
        } else if let string = try? container.decode(String.self) {
            self.value = string
        } else if let array = try? container.decode([AnyCodable].self) {
            self.value = array.map { $0.value }
        } else if let dict = try? container.decode([String: AnyCodable].self) {
            self.value = dict.mapValues { $0.value }
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Unsupported type")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()

        switch value {
        case is NSNull:
            try container.encodeNil()
        case let bool as Bool:
            try container.encode(bool)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let string as String:
            try container.encode(string)
        case let array as [Any]:
            try container.encode(array.map { AnyCodable($0) })
        case let dict as [String: Any]:
            try container.encode(dict.mapValues { AnyCodable($0) })
        default:
            try container.encode(String(describing: value))
        }
    }
}
#endif
      ]]>
    </any-codable-wrapper>

    <debug-logger-implementation>
      <![CDATA[
#if DEBUG
import Foundation
import os.log

/// Central debug logging service for iOS app.
/// DEBUG builds only - completely compiled out in Release.
@MainActor
public final class DebugLogger {
    private static let logger = Logger(subsystem: "app.rial", category: "debug-logger")

    /// Shared singleton instance
    public static let shared = DebugLogger()

    /// Buffer for pending log entries
    private var buffer: [DebugLogEntry] = []

    /// Log shipper for batch uploads
    private let shipper: DebugLogShipper

    /// Session ID for grouping logs within app session
    private var currentSessionId = UUID()

    /// Timer task for periodic flush
    private var shipTimer: Task<Void, Never>?

    /// Buffer size threshold for automatic shipping
    private let bufferThreshold = 50

    /// Flush interval in seconds
    private let flushInterval: TimeInterval = 30

    /// Keychain service for device ID access
    private let keychain = KeychainService()

    private init() {
        self.shipper = DebugLogShipper(baseURL: AppEnvironment.apiBaseURL)
        startFlushTimer()
    }

    /// Log a debug event.
    public func log(
        event: String,
        level: LogLevel = .info,
        payload: [String: Any] = [:],
        correlationId: UUID? = nil
    ) {
        let deviceId = getDeviceId()
        let typedPayload = payload.mapValues { AnyCodable($0) }

        let entry = DebugLogEntry(
            id: UUID(),
            correlationId: correlationId ?? UUID(),
            timestamp: Date(),
            source: .ios,
            level: level,
            event: event,
            payload: typedPayload,
            deviceId: deviceId,
            sessionId: currentSessionId
        )
        buffer.append(entry)

        Self.logger.debug("Buffered log: \(event) (buffer size: \(self.buffer.count))")

        // Ship if buffer exceeds threshold
        if buffer.count >= bufferThreshold {
            Task { await flush() }
        }
    }

    /// Force immediate ship (called on app background).
    public func flush() async {
        guard !buffer.isEmpty else { return }

        let entries = buffer
        buffer.removeAll()

        Self.logger.info("Flushing \(entries.count) log entries")
        await shipper.ship(entries)
    }

    /// Start periodic flush timer.
    private func startFlushTimer() {
        shipTimer = Task {
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: UInt64(flushInterval * 1_000_000_000))
                await flush()
            }
        }
    }

    /// Get device ID from keychain if available.
    private func getDeviceId() -> UUID? {
        guard let state = try? keychain.loadDeviceState(for: AppEnvironment.apiBaseURL) else {
            return nil
        }
        return UUID(uuidString: state.deviceId)
    }
}
#endif
      ]]>
    </debug-logger-implementation>

    <debug-log-shipper-implementation>
      <![CDATA[
#if DEBUG
import Foundation
import os.log

/// Batch uploads debug log entries to backend.
/// Uses dedicated URLSession to avoid circular logging through APIClient.
actor DebugLogShipper {
    private static let logger = Logger(subsystem: "app.rial", category: "debug-shipper")

    private let session: URLSession
    private let baseURL: URL

    /// JSON encoder with snake_case keys and ISO8601 dates
    private let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.keyEncodingStrategy = .convertToSnakeCase
        encoder.dateEncodingStrategy = .iso8601
        return encoder
    }()

    init(baseURL: URL) {
        self.baseURL = baseURL

        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 10
        config.timeoutIntervalForResource = 30
        config.httpAdditionalHeaders = [
            "Content-Type": "application/json",
            "Accept": "application/json"
        ]
        self.session = URLSession(configuration: config)
    }

    /// Ship batch of log entries to backend.
    /// Errors are logged but not propagated (debug logging should never crash the app).
    func ship(_ entries: [DebugLogEntry]) async {
        guard !entries.isEmpty else { return }

        let url = baseURL.appendingPathComponent("/debug/logs")
        var request = URLRequest(url: url)
        request.httpMethod = "POST"

        do {
            request.httpBody = try encoder.encode(entries)
        } catch {
            Self.logger.error("Failed to encode debug log entries: \(error.localizedDescription)")
            return
        }

        do {
            let (_, response) = try await session.data(for: request)

            if let httpResponse = response as? HTTPURLResponse {
                if httpResponse.statusCode == 201 {
                    Self.logger.info("Shipped \(entries.count) log entries successfully")
                } else {
                    Self.logger.warning("Debug log ship returned status \(httpResponse.statusCode)")
                }
            }
        } catch {
            // Silently fail - debug logging should never impact app functionality
            Self.logger.debug("Debug log ship failed (expected if backend not running): \(error.localizedDescription)")
        }
    }
}
#endif
      ]]>
    </debug-log-shipper-implementation>

    <api-client-correlation-id-integration>
      <![CDATA[
// Add to perform<T>(_ request: URLRequest) method in APIClient.swift:
func perform<T: Decodable>(_ request: URLRequest) async throws -> T {
    var request = request

    #if DEBUG
    // Add correlation ID for cross-stack tracing
    let correlationId = UUID()
    request.setValue(correlationId.uuidString, forHTTPHeaderField: "X-Correlation-ID")

    await DebugLogger.shared.log(
        event: "API_REQUEST",
        payload: [
            "method": request.httpMethod ?? "?",
            "path": request.url?.path ?? "?",
            "correlationId": correlationId.uuidString
        ],
        correlationId: correlationId
    )
    #endif

    Self.logger.debug("Request: \(request.httpMethod ?? "?") \(request.url?.path ?? "?")")
    // ... rest of existing implementation
}
      ]]>
    </api-client-correlation-id-integration>

    <background-flush-integration>
      <![CDATA[
// Add to RialApp.swift:
import SwiftUI

@main
struct RialApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @Environment(\.scenePhase) private var scenePhase

    @StateObject private var privacySettings = PrivacySettingsManager()
    @StateObject private var navigationState = AppNavigationState()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(privacySettings)
                .environmentObject(navigationState)
                .onChange(of: scenePhase) { oldPhase, newPhase in
                    if newPhase == .background {
                        #if DEBUG
                        Task {
                            await DebugLogger.shared.flush()
                        }
                        #endif
                    }
                }
        }
    }
}
      ]]>
    </background-flush-integration>
  </implementation-guidance>

  <file-inventory>
    <files-to-create>
      <file path="ios/Rial/Core/Debug/DebugLogEntry.swift" purpose="Log entry model with LogLevel, LogSource enums, AnyCodable wrapper, and Codable conformance">
        Contains: DebugLogEntry struct, LogLevel enum, LogSource enum, AnyCodable wrapper
        All wrapped in #if DEBUG
      </file>
      <file path="ios/Rial/Core/Debug/DebugLogger.swift" purpose="Central debug logger singleton with @MainActor, buffer management, and periodic flush">
        Contains: DebugLogger class with shared singleton, log(), flush(), timer management
        Uses KeychainService for device ID access
        All wrapped in #if DEBUG
      </file>
      <file path="ios/Rial/Core/Debug/DebugLogShipper.swift" purpose="Batch upload actor with dedicated URLSession">
        Contains: DebugLogShipper actor with ship() method
        Uses separate URLSession (not APIClient) to avoid circular logging
        All wrapped in #if DEBUG
      </file>
      <file path="ios/RialTests/Debug/DebugLogEntryTests.swift" purpose="Unit tests for DebugLogEntry Codable serialization">
        Test JSON encoding with correct snake_case keys
        Test decoding roundtrip
        Test AnyCodable with various types
      </file>
      <file path="ios/RialTests/Debug/DebugLoggerTests.swift" purpose="Unit tests for DebugLogger buffering logic">
        Test buffer fills and triggers flush at threshold
        Test flush clears buffer
        Test log() adds entries correctly
      </file>
      <file path="ios/RialTests/Debug/DebugLogShipperTests.swift" purpose="Unit tests for DebugLogShipper request creation">
        Test correct URL path (/debug/logs)
        Test correct Content-Type header
        Test JSON body structure
      </file>
    </files-to-create>
    <files-to-modify>
      <file path="ios/Rial/Core/Networking/APIClient.swift" changes="Add X-Correlation-ID header to all requests in perform() methods">
        Modify perform&lt;T&gt;(_ request:) to add header and log via DebugLogger
        Similar modification for get(), post() methods
        All additions wrapped in #if DEBUG
      </file>
      <file path="ios/Rial/App/RialApp.swift" changes="Add scenePhase observer for background flush">
        Add @Environment(\.scenePhase) property
        Add .onChange(of: scenePhase) modifier to flush on background
        Flush wrapped in #if DEBUG
      </file>
    </files-to-modify>
  </file-inventory>

  <testing-requirements>
    <test-framework>XCTest in ios/RialTests/Debug/</test-framework>
    <unit-tests>
      <test name="DebugLogEntry encodes to JSON with correct snake_case keys">
        Verify correlation_id, device_id, session_id keys in output
      </test>
      <test name="DebugLogEntry decodes from JSON correctly">
        Roundtrip encode/decode verification
      </test>
      <test name="LogLevel and LogSource enums serialize as expected strings">
        Verify "debug", "info", "warn", "error" for levels
        Verify "ios", "backend", "web" for sources
      </test>
      <test name="AnyCodable handles Bool, Int, Double, String, Array, Dictionary">
        Test each primitive type encodes/decodes correctly
      </test>
      <test name="DebugLogger buffers entries until threshold reached">
        Add 49 entries, verify no flush called
        Add 50th entry, verify flush triggered
      </test>
      <test name="DebugLogger flush clears buffer after shipping">
        Add entries, call flush(), verify buffer empty
      </test>
      <test name="DebugLogShipper creates correct POST request body">
        Verify URL path is /debug/logs
        Verify HTTP method is POST
        Verify Content-Type is application/json
      </test>
    </unit-tests>
    <integration-tests-manual>
      <test name="Build DEBUG scheme and verify debug code compiles">
        Xcode build with DEBUG configuration
      </test>
      <test name="Build RELEASE scheme and verify no debug code included">
        Check binary size difference, or search for debug symbols
      </test>
      <test name="Trigger API calls and verify X-Correlation-ID in request headers">
        Use Charles Proxy or backend logs
      </test>
      <test name="Put app in background and verify logs shipped">
        Monitor backend logs or network traffic
      </test>
      <test name="Run bun debug:search --source ios to verify logs appear in backend">
        Requires debug-1-backend-debug-endpoints story complete
      </test>
    </integration-tests-manual>
    <test-locations>
      <location>ios/RialTests/Debug/DebugLogEntryTests.swift</location>
      <location>ios/RialTests/Debug/DebugLoggerTests.swift</location>
      <location>ios/RialTests/Debug/DebugLogShipperTests.swift</location>
    </test-locations>
  </testing-requirements>

  <dependencies>
    <story-dependency story="debug-1-backend-debug-endpoints" status="done">
      Backend POST /debug/logs endpoint must be available for log shipping.
      If backend is not running, DebugLogShipper will silently fail (by design).
    </story-dependency>
    <framework-dependencies>
      <dependency name="Foundation" purpose="URLSession, JSONEncoder, UUID, Date" />
      <dependency name="os.log" purpose="Logger for internal debug output" />
      <dependency name="SwiftUI" purpose="scenePhase environment value" />
    </framework-dependencies>
    <internal-module-dependencies>
      <dependency name="KeychainService" purpose="Access device ID for log entries" />
      <dependency name="AppEnvironment" purpose="Get API base URL for shipper" />
    </internal-module-dependencies>
  </dependencies>

  <conventions>
    <code-style>
      - 4-space indentation
      - camelCase for functions/variables
      - PascalCase for types
      - /// doc comments for public items
      - #if DEBUG for debug-only code
      - Codable structs for JSON encoding
      - @MainActor for thread-safe singleton access
      - actor for thread-safe isolated state
    </code-style>
    <file-organization>
      - New files go in ios/Rial/Core/Debug/
      - Tests go in ios/RialTests/Debug/
      - Follow existing Core/ subdirectory pattern (Networking, Storage, etc.)
    </file-organization>
    <error-handling>
      - Debug logging should NEVER crash the app
      - All errors in DebugLogShipper are logged but not propagated
      - Use optional chaining for device ID access
    </error-handling>
  </conventions>
</story-context>
